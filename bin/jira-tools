#!/bin/bash

# A set of tools for making using JIRA more seamless
# with my personal workflows.
# Written by Shane Schulte

# Requirements:
# - fzf
# - go-jira (1.0.23 or newer)
# - Bash (4.4 or newer)
# - 256 color terminal support

# TODO List:
# - implement github daemon
#   - can steal from kazoo bot github poller
#   - the goal is to detect merged PRs and update associations
#   - If all branches merge and ticket is in review, finalize ticket
#   - pseudocode: jira view "$ticket" | grep "^status:" | sed 's/^status: //'

# ========================================================
# CONFIGURATION
# ========================================================
jira_link_base="https://samsaradev.atlassian.net/browse/"
new_ticket_text="-> Create new ticket..."
new_branch_text="-> Create new branch..."
extra_review_groups="
samsara-dev/mobile
"
jira_projects="
AA
MOB
"
jira_priorities="
Highest
High
Medium
Low
Lowest
"
jira_branch_map=~/.cache/jira-branch-associations
# ========================================================


# Layout of the association file (TSV):
# {status} {ticket} {branch}

touch "$jira_branch_map"

quickedit_markdown() (
    trap 'rm ~/temp$$.md' exit;
    touch ~/temp$$.md;
    $EDITOR ~/temp$$.md > /dev/tty \
        || vim ~/temp$$.md > /dev/tty;
    cat ~/temp$$.md;
)

# Helpers for colored text
colored_text() {
    printf "\e[38;5;%sm%s\e[0m" $1 "$2"
}

_red() { colored_text 160 "$@"; }
red() { _red "$@"; printf '\n'; }

_green() { colored_text 46 "$@"; }
green() { _green "$@"; printf '\n'; }

_yellow() { colored_text 226 "$@"; }
yellow() { _yellow "$@"; printf '\n'; }

# Helpers to read the association file
get_ticket_by_branch() {
# Usage: [branch]
    local -; set -o pipefail
    grep -P "\t$1$" "$jira_branch_map" | cut -f2
        return 1
    return $?
}

get_minimum_status_by_ticket() {
# Usage: [ticket]
    list=$(grep -P "\t$1\t" "$jira_branch_map" | cut -f1 | sort | uniq)
    echo $list | grep -o NONE \
        || echo $list | grep -o REVIEW \
        || echo $list | grep -o MERGED \
        || (echo NOTFOUND; return 1)
}

get_branch_status() {
# Usage: [branch]
    local -; set -o pipefail
    grep -P "\t$1$" "$jira_branch_map" | cut -f1
    return $?
}

get_branches_by_ticket() {
# Usage: [ticket]
    local -; set -o pipefail
    grep -P "\t$1\t" "$jira_branch_map" | cut -f3
    return $?
}

get_unmerged_branches_by_ticket() {
# Usage: [ticket]
    local -; set -o pipefail
    grep -P "^(NONE|REVIEW)\t" "$jira_branch_map" | cut -f3
    return $?
}

# Helpers to manipulate the association file
delete_fully_merged_ticket() {
# Usage: [ticket]
    min_status=$(get_minimum_status_by_ticket "$1")
    if [ "$min_status" = "MERGED" ]; then
        sed -i '/^MERGED\t'$1'\t.*$/d' "$jira_branch_map"
        return 0
    fi
    return 1
}

dangerously_delete_branch() {
# Usage: [branch]
    escaped=$(echo "$1" | sed 's;/;\\/;g')
    sed -i '/^[A-Z]*\t[A-Z0-9-]*\t'$escaped'$/d' "$jira_branch_map"
}

transition_branch() {
# Usage: [src status] [dest status] [branch]
    escaped=$(echo "$3" | sed 's;/;\\/;g')
    sed -i 's/^'$1'\(\t[A-Z0-9-]*\t'$escaped'$\)/'$2'\1/' "$jira_branch_map"
}

track_new_branch() {
# Usage: [branch] [ticket]
    echo "NONE $1 $2" > "$jira_branch_map"
}

# Git helpers
git_new_branch() {
    good_branch_name=1
    while [ $good_branch_name -ne 0 ]; do
        printf '\n'
        _green "Enter a name for your branch: "
        read branch_name

        case "$branch_name" in
             *\ * )
                   red "Your branch cannot contain spaces."
                   continue
                  ;;
        esac
        git checkout -b "$branch_name"
        good_branch_name=$?
    done
    return $good_branch_name
}

git_try_checkout_branch() {
# Usage: [branch]
    git checkout "$1"
    if [ $? -ne 0 ]; then
        yellow "Couldn't find branch locally. Attempting to fetch..."
        git fetch origin "$1"
        git checkout "$1"
        if [ $? -ne 0 ]; then
            red "Couldn't find branch remotely."
            _red "Want to delete the JIRA association? (y/n) "
            read -n 1 c; echo ""
            if [[ $c == [yY] ]]; then
                dangerously_delete_branch "$1"
            fi
            return 1
        fi
    fi
}

git_reset_to_latest_master() {
    _green "Pulling latest master... "
    while ! git fetch origin master &> /dev/null; do
        _red "Fetch failed. Try again? (y/n)"
        read -n 1 c; echo ""
        if [[ $c != [yY] ]]; then
            exit 1
        fi
    done
    git reset --hard origin/master &> /dev/null
    echo "Done."
}

create_ticket() {
    project=$(echo "$jira_projects" \
        | sed '/^$/d' \
        | fzf \
            --reverse \
            --height="40%" \
            --select-1 \
            --prompt="Select a project: ")

    if [ -z "$project" ]; then
        exit 0
    fi

    issuetype=$(jira issuetypes -p "$project" \
        | cut -d ':' -f1 \
        | fzf \
            --ansi \
            --reverse \
            --height="40%" \
            --prompt="Select an issue type: ")

    if [ -z "$issuetype" ]; then
        exit 0
    fi

    read -p "Describe the ticket (title): " title
    description=$(quickedit_markdown)
    if [ "$description" = "" ]; then
        exit 0
    fi

    read -p "Estimated effort (days): " story_points

    priority=$(echo "$jira_priorities" \
        | sed '/^$/d' \
        | fzf \
            --ansi \
            --reverse \
            --height="40%" \
            --prompt="Select a priority level: ")

    if [ -z "$priority" ]; then
        exit 0
    fi

    sprint=$(jira current-sprint "$project")

    if response=$(jira create \
        --project="$project" \
        --override="summary: $title" \
        --override="description: $description" \
        --override="priority: $priority" \
        --override="storypoints: $story_points" \
        --override="sprint: $sprint" \
        --issuetype="$issuetype" \
        --noedit); then
        rstatus=$(echo $response | cut -d ' ' -f1)
        if [ "$rstatus" != "OK" ]; then
            return 1
        fi
        ticket=$(echo $response | cut -d ' ' -f2)
        url=$(echo $response | cut -d ' ' -f3)
        jira take $ticket
        green "Ticket successfully created: $url"
        return 0
    fi
    return 1
}

start_work() {
    git diff-index --cached --quiet HEAD
    has_local_changes=$?

    if [ $has_local_changes -ne 0 ]; then
        red "Uncommitted changes detected. Please commit or stash them first."
        exit 1
    fi

    ticket_text=$( (jira unstarted; green "$new_ticket_text") \
        | sed '/^$/d' \
        | fzf \
        --ansi \
        --cycle \
        --reverse \
        --prompt="Search for a JIRA ticket: " \
        --height="40%" \
        --preview="echo {} | cut -d ':' -f1 | xargs jira")

    if [ -z "$ticket_text" ]; then
        exit 0
    fi

    if [ "$ticket_text" = "$new_ticket_text" ]; then
        # TODO: implement
        yellow "coming soon!"
        exit 0
        ticket="MOB-NEW"
    else
       # Split the ticket from the FZF string
       ticket=$(echo "$ticket_text" \
           | grep --color=never -oE "^[-A-Z0-9]*:" \
           | tr -d ':')
    fi

    branches=$(get_unmerged_branches_by_ticket "$ticket")
    selected_branch=$( (echo "$branches"; green "$new_branch_text") \
        | sed '/^$/d' \
        | fzf \
        --ansi \
        --cycle \
        --reverse \
        --select-1 \
        --prompt="Choose a branch to continue: " \
        --height="40%" \
        --preview="git log --oneline -n 20 --color=always {}")

    if [ -z "$selected_branch" ]; then
        exit 0
    fi

    if [ "$selected_branch" = "$new_branch_text" ]; then
        git_new_branch
        git_reset_to_latest_master
        selected_branch="$(git rev-parse --abbrev-ref HEAD)"
        green "Transitioning '$ticket' into 'In Progress'..."
        jira transition "In Progress" "$ticket" --noedit
        track_new_branch "$selected_branch" "$ticket"
    else
        if ! git_try_checkout_branch "$selected_branch"; then
            exit 1
        fi
    fi
}

find_samsara_reviewers() {
    echo $review_teams
    rg -I "GithubUsername:\s+\".*\"" "go/src/samsaradev.io/team" \
            | sed 's/^[ \t]*GithubUsername:[ \t]*"\(.*\)".*$/\1/' \
            | sort
}

pull_request() {
    pushd $(git rev-parse --show-toplevel)

    branch_name=$(git rev-parse --abbrev-ref HEAD)

    reviewers=$(find_reviewers \
        | fzf -m \
        | paste -s -d ',')

    if status=$(get_branch_status "$branch_name"); then
        if [ "$status" = "REVIEW" ]; then
            yellow "This branch already has an open PR."
            _yellow "Would you like to view it in browser?"
            read -n 1 c; echo ""
            if [[ $c == [yY] ]]; then
                gh pr view
            fi
            exit 1
        fi
        if [ "$status" = "MERGED" ]; then
            red "This branch already has a merged PR."
            exit 1
        fi
        if ticket=$(get_ticket_by_branch "$branch_name"); then

            template=$(cat .github/PULL_REQUEST_TEMPLATE.md \
                | sed -e "s@\(\*\*JIRA ticket\*\*: \)link@\1${jira_link_base}${ticket}@")
            title=$(jira "$ticket" | grep "^summary:" | sed 's/^summary: //')
            hub pull-request \
                --message "$title" \
                --message "$template" \
                --reviewer "$reviewers" \
                --edit
            if [[ $? -ne 0 ]]; then
                exit 1
            fi
            transition_branch "NONE" "REVIEW" "$branch_name"
            _green "Is this ticket ready for review? (y/n) "
            read -n 1 c; echo ""
            if [[ $c == [yY ]]; then
                jira transition "In Review" "$ticket" --noedit
            else
                _yellow "start a new branch based on this one? (y/n) "

                read -n 1 c; echo ""
                if [[ $c == [yY ]]; then
                    git_new_branch
                    next_branch=$(git rev-parse --abbrev-ref HEAD)
                    track_new_branch "$next_branch" "$ticket"
                fi
            fi
            exit 0
        fi
    fi

    hub pull-request \
        --reviewer "$reviewers" \
        --edit

    exit $?
}

# Runner Program
subcommand=$1
shift
case "$subcommand" in
    start)
        start_work $@
        ;;
    pull-request)
        pull_request $@
        ;;
    create-ticket)
        create_ticket $@
        ;;
esac
